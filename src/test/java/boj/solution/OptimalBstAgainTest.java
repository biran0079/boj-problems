package boj.solution;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.Timeout;

import static org.junit.Assert.*;

/**
 * Created by biran on 10/30/16.
 */
public class OptimalBstAgainTest {

  @Rule
  public final Timeout globalTimeout = Timeout.seconds(1);
  private final OptimalBstAgain solver = new OptimalBstAgain();

  @Test
  public void test() {
    test(new double[] {0.9, 0.05, 0.05}, 1.15);
    test(new double[] {1.0}, 1.0);
    test(new double[] {0.2739738747444806, 0.7260261252555194}, 1.2739738747444806);
    test(new double[] {0.3716154142117468, 0.40341952640234396, 0.2249650593859092}, 1.596580473597656);
    test(new double[] {0.12073145950536696, 0.3086830088697123, 0.27556585895784436, 0.29501967266707635}, 1.8451656005475225);
    test(new double[] {0.24540025301471846, 0.11504250654532798, 0.13084402599302652, 0.020740348718583396, 0.48797286572834364}, 1.9144368707925057);
    test(new double[] {0.24909556415911563, 0.02698654331360522, 0.16145495852602101, 0.10609528677088848, 0.20049619755636602, 0.2558714496740037}, 2.2086677400008483);
    test(new double[] {0.09650376257577585, 0.14780428668222417, 0.1452117478230263, 0.16187792554200048, 0.16615479777585393, 0.10432071133077542, 0.17812676827034396}, 2.424119150903);
    test(new double[] {0.04129321216888507, 0.02560786408382134, 0.3016912493974252, 0.22270032317246788, 0.22044170900073579, 0.04415437356960522, 0.14272837221244333, 0.0013828963946162752}, 2.103611529304946);
    test(new double[] {0.01601493589436867, 0.07804278539694406, 0.07588114899555817, 0.19248761461678252, 0.21761719518794534, 0.19391876292094976, 0.1372122844924399, 0.0400915896116782, 0.04873368288333354}, 2.3670533850164928);
    test(new double[] {0.016245577125949033, 1.8391329038281565E-4, 0.013161929016603267, 0.014664262686990278, 0.013549669353971738, 0.004016023537288008, 0.014888215914697913, 0.017972749779730488, 2.70662701266278E-4, 0.007494628903713307, 0.01623233727160778, 0.014944300805802281, 0.0188879668297178, 0.01678965032008196, 0.0032375959467136582, 0.018290929827908562, 0.013770354060056937, 0.012877910508892098, 0.015293228844519334, 0.00839244048805475, 0.008785253160852182, 0.016214022770787335, 0.009540923583119015, 0.01885889784463009, 0.018427835648255415, 0.006713280375037957, 8.986224171260556E-4, 0.0013617139532959436, 5.533943177878923E-4, 0.009195575638745606, 0.018478792030528036, 0.018805172949233572, 0.014590669532690143, 0.009532605814093613, 0.004858067278141845, 0.00587773973533584, 0.01612757548988553, 9.902353301614937E-4, 1.9345654076010122E-4, 0.0067274804495273096, 0.0016490669142658792, 0.0161661893064161, 6.99055563477621E-5, 0.005853689083093069, 0.01010698362065258, 0.0174685677633437, 0.005270338785980511, 0.01662154180105477, 0.011595115231229403, 0.01727512001366209, 8.458591644393236E-4, 0.012295565596249525, 0.009445272169891073, 0.00963345053546735, 0.00989937673548659, 0.0069652792464087, 0.009080870476973637, 0.013383927323403991, 0.0061364867283881545, 2.2158270061269284E-4, 0.01332820734798936, 0.01417070711717122, 0.01154581187433823, 0.004469392233995369, 0.007396519558768769, 0.017328908076450718, 0.0031824144978712257, 7.440435143911082E-5, 0.005036220274807509, 0.016974306105779217, 0.005657391221656204, 0.008154365644523962, 0.013071785741207917, 0.0077663662973212035, 0.006712261845975783, 0.012771526641067331, 0.01407686957716954, 0.017005072731729135, 0.011026202921803811, 0.009710523296355023, 0.005931193138760276, 0.010270883858385588, 0.01850079908599903, 0.011666526290553002, 5.165403379414742E-4, 0.013099655097637162, 0.011983109213503637, 0.015548790893592153, 0.014090200205266724, 0.012004798283490516, 0.005986758059551141, 0.014265744268589495, 0.003616472564431378, 0.0023290048590174873, 0.013561106409934213, 0.0177390893030505, 0.005914824496386222, 0.010067518716176081, 0.0034027427370017754, 0.0021651339960016298}, 5.263044588485213);
  }

  private void test(double[] data, double expected) {
    assertEquals(expected,
        searchDepthExp(data, solver.solve(data, Node::new)), 1e-6);
  }

  private double searchDepthExp(double[] prob, OptimalBstAgain.TreeNode root) {
    return searchDepthExpHelper(prob, root, 1);
  }

  private double searchDepthExpHelper(double[] prob, OptimalBstAgain.TreeNode root, int depth) {
    if (root == null) {
      return 0;
    }
    return depth * prob[root.getValue()]
        + searchDepthExpHelper(prob, root.getLeft(), depth + 1)
        + searchDepthExpHelper(prob, root.getRight(), depth + 1);
  }


  private static final class Node implements OptimalBstAgain.TreeNode {

    private int value;
    private OptimalBstAgain.TreeNode left;
    private OptimalBstAgain.TreeNode right;

    Node(int value, OptimalBstAgain.TreeNode left, OptimalBstAgain.TreeNode right) {
      this.value = value;
      this.left = left;
      this.right = right;
    }

    @Override
    public int getValue() {
      return value;
    }

    @Override
    public OptimalBstAgain.TreeNode getLeft() {
      return left;
    }

    @Override
    public OptimalBstAgain.TreeNode getRight() {
      return right;
    }
  }
}